.table instr

# 0: x = 1
# 1: x += 1
# 2: y = x > 10
# 3: goto 0 if y
# 4: print "foo"

instr{idx: 0, op: store{var: "x", val: 0}}.
instr{idx: 1, op: increment{var: "x"}}.
instr{idx: 2, op: store{var: "y", val: gt{var: "x", val: 2}}}.
instr{idx: 3, op: conditionalGoto{dest: 1, var: "y"}}.
instr{idx: 5, op: stop{}}.

# instr{idx: 0, op: store{var: "x", val: 0}}.
# instr{idx: 1, op: increment{var: "x"}}.
# instr{idx: 2, op: stop{}}.

timeLimit{limit: 20}.

state{time: T, state: S} :-
  initialState{time: T, state: S} |
  laterState{time: T, state: S}.

initialState{time: 0, state: state{vars: {}, pc: 0, done: false}}.

# how do we get the op
laterState{time: T, state: NextState} :-
  timeLimit{limit: Limit} &
  range{from: 0, to: Limit, val: T} &
  T = PrevT + 1 &
  state{time: PrevT, state: PrevState} &
  stepOp{fromState: PrevState, toState: NextState}.

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  base.eq{a: Val, b: true} &
  base.eq{a: FromVars, b: ToVars}.
stepConditionalGotoNo{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  base.neq{a: Val, b: true} &
  base.eq{a: FromVars, b: ToVars} &
  ToPC = FromPC + 1.

stepStop{
  fromState: state{pc: PC, vars: FromVars},
  toState: state{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  base.eq{a: FromVars, b: ToVars}.

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalGt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalGt{vars: FromVars, expr: gt{var: Var, val: LiteralVal}, value: true} :-
  evalGtTrue{vars: FromVars, expr: gt{var: Var, val: LiteralVal}, value: V} |
  evalGtFalse{vars: FromVars, expr: gt{var: Var, val: LiteralVal}, value: V}.
# this pattern is so wonky lol
evalGtTrue{vars: FromVars, expr: gt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal > LiteralVal.
evalGtFalse{vars: FromVars, expr: gt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal <= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  base.eq{a: Expr, b: Value}.

# debugging

storeGtTest{pc: PC, resVar: ResVar, gtVar: GtVar, gtVal: GtVal, vars: Vars, gtVarVal: GtVarVal, value: true} :-
  instr{idx: PC, op: store{var: ResVar, val: gt{var: GtVar, val: GtVal}}} &
  base.eq{a: Vars, b: {"x": 10}} &
  dict.item{dict: Vars, key: GtVar, value: GtVarVal} &
  base.gt{a: GtVarVal, b: GtVal}.

evalGtTest{value: Value} :-
  evalGt{vars: {"x": 10}, expr: gt{var: "x", val: 3}, value: Value}.
