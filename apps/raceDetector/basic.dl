.table instr

timeLimit{limit: 10}.

# Overall control flow

state{time: T, state: S} :-
  initialState{time: T, state: S} |
  laterState{time: T, state: S}.

initialState{
  time: 0,
  state: state{
    threads: {
      "1": threadState{
        vars: {},
        pc: 0,
        done: false
      }
    },
    nextThreadID: 2
  }
}.

laterState{time: T, state: state{threads: NewThreadStates, nextThreadID: NextThreadID}} :-
  timeLimit{limit: Limit} &
  range{from: 0, to: Limit, val: T} &
  T = PrevT + 1 &
  state{time: PrevT, state: state{threads: ThreadStates, nextThreadID: NextThreadID}} &
  dict.item{dict: ThreadStates, key: ThreadID, value: FromThreadState} &
  stepOp{fromState: FromThreadState, toState: ToThreadState} &
  dict.set{in: ThreadStates, key: ThreadID, value: ToThreadState, out: NewThreadStates}.

finalState{vars: V, time: T} :-
  state{time: T, state: state{vars: V, done: true}}.

# Individual ops

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val = true &
  FromVars = ToVars.
stepConditionalGotoNo{
  fromState: state{pc: FromPC, vars: FromVars},
  toState: state{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val != true &
  FromVars = ToVars &
  ToPC = FromPC + 1.

stepFork{
  fromState: state{pc: PC, vars: FromVars},
  toState: state{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: fork{var: V}} &
  FromVars = ToVars.

stepStop{
  fromState: state{pc: PC, vars: FromVars},
  toState: state{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  FromVars = ToVars.

# Expressions

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalLt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalLt{vars: FromVars, expr: Expr, value: V} :-
  evalLtTrue{vars: FromVars, expr: Expr, value: V} |
  evalLtFalse{vars: FromVars, expr: Expr, value: V}.
# this pattern is so wonky lol
evalLtTrue{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal < LiteralVal.
evalLtFalse{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal >= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# debugging

storeGtTest{pc: PC, resVar: ResVar, gtVar: GtVar, gtVal: GtVal, vars: Vars, gtVarVal: GtVarVal, value: true} :-
  instr{idx: PC, op: store{var: ResVar, val: gt{var: GtVar, val: GtVal}}} &
  Vars = {"x": 10} &
  dict.item{dict: Vars, key: GtVar, value: GtVarVal} &
  GtVarVal > GtVal.

evalLtTest{value: Value} :-
  evalLt{vars: {"x": 10}, expr: gt{var: "x", val: 3}, value: Value}.
