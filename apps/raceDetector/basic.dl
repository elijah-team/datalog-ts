.table instr

timeLimit{limit: 10}.

# Overall control flow

state{time: T, threadID: I, state: S} :-
  initialState{time: T, threadID: I, state: S} |
  laterState{time: T, threadID: I, state: S}.

initialState{
  time: 0,
  threadID: 1,
  state: threadState{
    vars: {},
    pc: 0,
    done: false
  }
}.

laterState{time: T, threadID: I, state: ToState} :-
  timeLimit{limit: Limit} &
  range{from: 0, to: Limit, val: T} &
  T = PrevT + 1 &
  state{time: PrevT, threadID: I, state: FromState} &
  stepState{fromState: FromState, toState: ToState}.

# Individual ops

stepState{fromState: FromState, toState: ToState, forked: F} :-
  stepStateNormal{fromState: FromState, toState: ToState, forked: F} |
  stepStateFork{fromState: FromState, toState: ToState, forked: F}.

stepStateFork{fromState: FromState, toState: ToState, forked: F} :-
  stepForkOrig{fromState: FromState, toState: ToState, forked: F} |
  stepForkForked{fromState: FromState, toState: ToState, forked: F}.

stepForkOrig{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  forked: false
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = GotoPC &
  ToVars = FromVars.

stepForkForked{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  forked: true
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = FromPC + 1 &
  ToVars = FromVars.

stepStateNormal{
  fromState: FromState,
  toState: ToState,
  forked: false
} :-
  stepOp{fromState: FromState, toState: ToState}.

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val = true &
  FromVars = ToVars.
stepConditionalGotoNo{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val != true &
  FromVars = ToVars &
  ToPC = FromPC + 1.

stepStop{
  fromState: threadState{pc: PC, vars: FromVars},
  toState: threadState{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  FromVars = ToVars.

# Expressions

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalLt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalLt{vars: FromVars, expr: Expr, value: V} :-
  evalLtTrue{vars: FromVars, expr: Expr, value: V} |
  evalLtFalse{vars: FromVars, expr: Expr, value: V}.
# this pattern is so wonky lol
evalLtTrue{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal < LiteralVal.
evalLtFalse{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal >= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# debugging

stepStateNormalTest{toState: ToState, forked: F} :-
  initialState{state: S} &
  stepState{fromState: S, toState: ToState, forked: F}.

# viz

finalState{vars: V, threadID: I, time: T} :-
  state{time: T, threadID: I, state: threadState{vars: V, done: true}}.

viz.threadNode{id: I, parentID: P, display: thread{id: I, spawnedAt: T}} :-
  viz.initialThreadNode{id: I, parentID: P, spawnedAt: T} |
  viz.childThreadNode{id: I, parentID: P, spawnedAt: T}.

viz.initialThreadNode{id: I, parentID: -1, spawnedAt: T} :-
  initialState{time: T, state: state{threads: Threads}} &
  dict.item{dict: Threads, key: I, value: V}.

viz.childThreadNode{id: I, parentID: P, spawnedAt: T} :-
  state{time: T, state: S, threadID: P} &
  stepForkForked{fromState: S, fromThreadID: P, toThreadID: I}.

internal.visualization{
  name: "Thread Tree",
  spec: tree{
    nodes: viz.threadNode{id: ID, parentID: ParentID, display: Display},
    rootTerm: -1
  }
}.
