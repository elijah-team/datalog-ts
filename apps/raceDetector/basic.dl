.table instr

timeLimit{limit: 20}.
threadLimit{limit: 10}.

# Overall control flow

state{time: T, threadID: I, state: S} :-
  initialState{time: T, threadID: I, state: S} |
  laterState{time: T, threadID: I, state: S}.

initialState{
  time: 0,
  threadID: 1,
  state: threadState{
    vars: {},
    pc: 0,
    done: false
  }
}.

laterState{time: T, threadID: TT, state: ToState} :-
  timeLimit{limit: TimeLimit} &
  threadLimit{limit: ThreadLimit} &
  range{from: 0, to: TimeLimit, val: T} &
  range{from: 0, to: ThreadLimit, val: FT} &
  T = PrevT + 1 &
  state{time: PrevT, threadID: FT, state: FromState} &
  stepState{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT}.

# Individual ops

stepState{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT} :-
  stepStateNormal{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT} |
  stepStateFork{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT}.

stepStateFork{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT} :-
  stepForkOrig{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT} |
  stepForkForked{fromState: FromState, toState: ToState, fromThread: FT, toThread: TT}.

stepForkOrig{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  fromThread: FT, toThread: TT
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = GotoPC &
  ToVars = FromVars &
  FT = TT.

stepForkForked{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  fromThread: FT, toThread: TT
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = FromPC + 1 &
  ToVars = FromVars &
  TT = FT + 1.
# ughhh

stepStateNormal{
  fromState: FromState,
  toState: ToState,
  fromThread: FT, toThread: TT
} :-
  stepOp{fromState: FromState, toState: ToState} &
  FT = TT.

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val = true &
  FromVars = ToVars.
stepConditionalGotoNo{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val != true &
  FromVars = ToVars &
  ToPC = FromPC + 1.

stepStop{
  fromState: threadState{pc: PC, vars: FromVars},
  toState: threadState{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  FromVars = ToVars.

# Expressions

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalLt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalLt{vars: FromVars, expr: Expr, value: V} :-
  evalLtTrue{vars: FromVars, expr: Expr, value: V} |
  evalLtFalse{vars: FromVars, expr: Expr, value: V}.
# this pattern is so wonky lol
evalLtTrue{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal < LiteralVal.
evalLtFalse{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal >= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# debugging

stepStateNormalTest{toState: ToState, toThread: TT} :-
  initialState{state: S} &
  stepState{fromState: S, toState: ToState, fromThread: I, toThread: TT}.

# viz

finalState{vars: V, threadID: I, time: T} :-
  state{time: T, threadID: I, state: threadState{vars: V, done: true}}.

viz.threadNode{id: I, parentID: P, display: thread{id: I, spawnedAt: T}} :-
  viz.initialThreadNode{id: I, parentID: P, spawnedAt: T} |
  viz.childThreadNode{id: I, parentID: P, spawnedAt: T}.

viz.initialThreadNode{id: I, parentID: -1, spawnedAt: T} :-
  initialState{time: T, threadID: I}.

viz.childThreadNode{id: I, parentID: P, spawnedAt: T} :-
  state{time: T, state: S, threadID: P} &
  stepForkForked{fromState: S, fromThread: P, toThread: I}.

internal.visualization{
  name: "Thread Tree",
  spec: tree{
    nodes: viz.threadNode{id: ID, parentID: ParentID, display: Display},
    rootTerm: -1
  }
}.
