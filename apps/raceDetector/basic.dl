.table instr

timeLimit{limit: 10}.

# Overall control flow

state{time: T, state: S} :-
  initialState{time: T, state: S} |
  laterState{time: T, state: S}.

initialState{
  time: 0,
  state: state{
    threads: {
      "1": threadState{
        vars: {},
        pc: 0,
        done: false
      }
    },
    nextThreadID: 2
  }
}.

laterState{time: T, state: ToState} :-
  timeLimit{limit: Limit} &
  range{from: 0, to: Limit, val: T} &
  T = PrevT + 1 &
  state{time: PrevT, state: FromState} &
  stepState{fromState: FromState, toState: ToState}.

finalState{vars: V, time: T} :-
  state{time: T, state: state{vars: V, done: true}}.

# Individual ops

stepState{fromState: FromState, toState: ToState} :-
  stepStateNormal{fromState: FromState, toState: ToState} |
  stepStateFork{fromState: FromState, toState: ToState}.

stepStateFork{
  fromState: state{threads: FromThreadStates, nextThreadID: FromNextThreadID},
  toState: state{threads: ToThreadStates, nextThreadID: ToNextThreadID},
  origThreadID: ThreadID,
  forkedThreadID: NextThreadIDStr
} :-
  intToString{int: FromNextThreadID, string: NextThreadIDStr} &
  dict.item{dict: FromThreadStates, key: ThreadID, value: FromThreadState} &
  stepThreadsFork{fromThreadState: FromThreadState, nextThreadOrig: Orig, nextThreadForked: Forked} &
  dict.set{in: FromThreadStates, key: ThreadID, value: Orig, out: IntermediateThreadStates} &
  dict.set{in: IntermediateThreadStates, key: NextThreadIDStr, value: Forked, out: ToThreadStates} &
  ToNextThreadID = FromNextThreadID + 1.

stepThreadsFork{
  fromThreadState: threadState{vars: FromVars, pc: FromPC},
  nextThreadOrig: threadState{vars: OrigVars, pc: ToPC, done: false},
  nextThreadForked: threadState{vars: ForkedVars, pc: ToPC, done: false}
} :-
  instr{idx: FromPC, op: fork{var: ForkVar}} &
  dict.set{in: FromVars, key: ForkVar, value: false, out: OrigVars} &
  dict.set{in: FromVars, key: ForkVar, value: true, out: ForkedVars} &
  ToPC = FromPC + 1.

stepStateNormal{
  fromState: state{threads: FromThreadStates, nextThreadID: FromNextThreadID},
  toState: state{threads: ToThreadStates, nextThreadID: ToNextThreadID}
} :-
  stepThreads{fromThreads: FromThreadStates, toThreads: ToThreadStates} &
  ToNextThreadID = FromNextThreadID.

stepThreads{fromThreads: FromThreadStates, toThreads: ToThreadStates} :-
  dict.item{dict: FromThreadStates, key: ThreadID, value: FromThreadState} &
  stepOp{fromState: FromThreadState, toState: ToThreadState} &
  dict.set{in: FromThreadStates, key: ThreadID, value: ToThreadState, out: ToThreadStates}.

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val = true &
  FromVars = ToVars.
stepConditionalGotoNo{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val != true &
  FromVars = ToVars &
  ToPC = FromPC + 1.

stepStop{
  fromState: threadState{pc: PC, vars: FromVars},
  toState: threadState{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  FromVars = ToVars.

# Expressions

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalLt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalLt{vars: FromVars, expr: Expr, value: V} :-
  evalLtTrue{vars: FromVars, expr: Expr, value: V} |
  evalLtFalse{vars: FromVars, expr: Expr, value: V}.
# this pattern is so wonky lol
evalLtTrue{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal < LiteralVal.
evalLtFalse{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal >= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# debugging

stepStateForkTest{toState: ToState} :-
  stepStateFork{
    fromState: state{
      threads: {"1": threadState{vars: {}, pc: 1, done: false}},
      nextThreadID: 2,
    },
    toState: ToState
  }.

stepThreadsTest{toThreads: ToThreads} :-
  stepThreads{fromThreads: {"1": threadState{pc: 1, vars: {"x": 0}, done: false}}, toThreads: ToThreads}.

stepOpTest{afterThreadState: TS} :-
  stepOp{fromState: threadState{pc: 1, vars: {"x": 0}, done: false}, toState: TS}.

stepIncrementTest{afterThreadState: TS} :-
  stepIncrement{fromState: threadState{pc: 1, vars: {"x": 0}, done: false}, toState: TS}.

# viz

viz.threadNode{id: I, parentID: P, display: I} :-
  viz.initialThreadNode{id: I, parentID: P, display: I} |
  viz.childThreadNode{id: I, parentID: P, display: I}.

viz.initialThreadNode{id: I, parentID: -1, display: I} :-
  initialState{state: state{threads: Threads}} &
  dict.item{dict: Threads, key: I, value: V}.

viz.childThreadNode{id: I, parentID: P, display: I} :-
  stepStateFork{forkedThreadID: I, origThreadID: P}.

internal.visualization{
  name: "Thread Tree",
  spec: tree{
    nodes: viz.threadNode{id: ID, parentID: ParentID, display: Display},
    rootTerm: 1
  }
}.
