.table instr

timeLimit{limit: 5}.

# Overall control flow

state{time: T, threadID: I, state: S} :-
  initialState{time: T, threadID: I, state: S} |
  laterState{time: T, threadID: I, state: S}.

initialState{
  time: 0,
  threadID: 1,
  state: threadState{
    vars: {},
    pc: 0,
    done: false
  }
}.

laterState{time: T, threadID: J, state: ToState} :-
  timeLimit{limit: Limit} &
  range{from: 0, to: Limit, val: T} &
  T = PrevT + 1 &
  state{time: PrevT, threadID: I, state: FromState} &
  stepState{fromState: FromState, toState: ToState, fromThreadID: I, toThreadID: J}.

finalState{vars: V, time: T} :-
  state{time: T, state: state{vars: V, done: true}}.

# Individual ops

stepState{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT} :-
  stepStateNormal{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT} |
  stepStateFork{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT}.

stepStateFork{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT} :-
  stepForkOrig{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT} |
  stepForkForked{fromState: FromState, toState: ToState, fromThreadID: FT, toThreadID: TT}.

stepForkOrig{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  fromThreadID: FT,
  toThreadID: TT
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = GotoPC &
  ToVars = FromVars &
  FT = TT.

stepForkForked{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars},
  fromThreadID: FT,
  toThreadID: TT
} :-
  instr{idx: FromPC, op: fork{goto: GotoPC}} &
  ToPC = FromPC + 1 &
  ToVars = FromVars &
  TT = FT + 1.
# TODO: better id strategy

stepStateNormal{
  fromState: FromState,
  toState: ToState,
  fromThreadID: FT,
  toThreadID: TT
} :-
  stepOp{fromState: FromState, toState: ToState} &
  FT = TT.

stepOp{fromState: FromState, toState: ToState} :-
  stepStore{fromState: FromState, toState: ToState} |
  stepIncrement{fromState: FromState, toState: ToState} |
  stepConditionalGoto{fromState: FromState, toState: ToState} |
  stepStop{fromState: FromState, toState: ToState}.

stepStore{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: store{var: Var, val: Expr}} &
  eval{vars: FromVars, expr: Expr, value: Value} &
  dict.set{in: FromVars, key: Var, value: Value, out: ToVars} &
  ToPC = FromPC + 1.

stepIncrement{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: increment{var: Var}} &
  dict.item{dict: FromVars, key: Var, value: OldValue} &
  NewValue = OldValue + 1 &
  dict.set{in: FromVars, key: Var, value: NewValue, out: ToVars} &
  ToPC = FromPC + 1.

stepConditionalGoto{fromState: FromState, toState: ToState} :-
  stepConditionalGotoYes{fromState: FromState, toState: ToState} |
  stepConditionalGotoNo{fromState: FromState, toState: ToState}.

stepConditionalGotoYes{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: ToPC}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val = true &
  FromVars = ToVars.
stepConditionalGotoNo{
  fromState: threadState{pc: FromPC, vars: FromVars},
  toState: threadState{pc: ToPC, vars: ToVars, done: false}
} :-
  instr{idx: FromPC, op: conditionalGoto{var: Var, dest: Dest}} &
  dict.item{dict: FromVars, key: Var, value: Val} &
  Val != true &
  FromVars = ToVars &
  ToPC = FromPC + 1.

stepStop{
  fromState: threadState{pc: PC, vars: FromVars},
  toState: threadState{pc: PC, vars: ToVars, done: true}
} :-
  instr{idx: PC, op: stop{}} &
  FromVars = ToVars.

# Expressions

eval{vars: FromVars, expr: Expr, value: Value} :-
  evalLt{vars: FromVars, expr: Expr, value: Value} |
  evalIntLit{expr: Expr, value: Value}.

evalLt{vars: FromVars, expr: Expr, value: V} :-
  evalLtTrue{vars: FromVars, expr: Expr, value: V} |
  evalLtFalse{vars: FromVars, expr: Expr, value: V}.
# this pattern is so wonky lol
evalLtTrue{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal < LiteralVal.
evalLtFalse{vars: FromVars, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  dict.item{dict: FromVars, key: Var, value: VarVal} &
  VarVal >= LiteralVal.
evalIntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# debugging

stepStateForkTest{toState: ToState} :-
  stepStateFork{
    fromState: state{
      threads: {"1": threadState{vars: {}, pc: 1, done: false}},
      nextThreadID: 2,
    },
    toState: ToState
  }.

stepThreadsTest{toThreads: ToThreads} :-
  stepThreads{fromThreads: {"1": threadState{pc: 1, vars: {"x": 0}, done: false}}, toThreads: ToThreads}.

stepOpTest{afterThreadState: TS} :-
  stepOp{fromState: threadState{pc: 1, vars: {"x": 0}, done: false}, toState: TS}.

stepIncrementTest{afterThreadState: TS} :-
  stepIncrement{fromState: threadState{pc: 1, vars: {"x": 0}, done: false}, toState: TS}.

# viz

viz.threadNode{id: I, parentID: P, display: thread{id: I, spawnedAt: T}} :-
  viz.initialThreadNode{id: I, parentID: P, spawnedAt: T} |
  viz.childThreadNode{id: I, parentID: P, spawnedAt: T}.

viz.initialThreadNode{id: I, parentID: -1, spawnedAt: T} :-
  initialState{time: T, state: state{threads: Threads}} &
  dict.item{dict: Threads, key: I, value: V}.

viz.childThreadNode{id: I, parentID: P, spawnedAt: T} :-
  state{time: T, state: S, threadID: P} &
  stepForkForked{fromState: S, fromThreadID: P, toThreadID: I}.

internal.visualization{
  name: "Thread Tree",
  spec: tree{
    nodes: viz.threadNode{id: ID, parentID: ParentID, display: Display},
    rootTerm: -1
  }
}.
