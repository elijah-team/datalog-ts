countUp {
  x = 0;
  goto loop;
}
loop {
  threshold = 5;
  x = prim.incr(x);
  going = prim.lt(x, threshold);
  goto loop if going;
}
state.Var{var: "x"}?
----
application/datalog

countUp {
  x = 0;
  goto loop;
}
loop {
  forkTo afterFork;
  x = prim.incr(x);
  threshold = 5;
  going = prim.lt(x, threshold);
  goto loop if going;
}
afterFork {
  done = 42;
}
state.ProgramCounter{}?
----
application/datalog
state.ProgramCounter{counter: 0, state: running{}, thread: 1, time: 1}.

main {
  x = 5;
  block.sleep(x);
  z = 10;
}
state.ProgramCounter{}?
----
application/datalog
state.ProgramCounter{counter: 0, state: running{}, thread: 1, time: 1}.

main {
  x = 5;
  block.sleep(x);
  z = 10;
}
state.Timer{}?
----
application/datalog

countUp {
  x = 0;
  goto loop;
}
loop {
  forkTo afterFork;
  x = prim.incr(x);
  threshold = 5;
  going = prim.lt(x, threshold);
  goto loop if going;
  goto end;
}
afterFork {
  x = 5;
  block.sleep(x);
  z = 10;
}
end {}
state.Timer{}?
----
application/datalog

main {
  lock = prim.newLock();
  block.acquireLock(lock);
  z = 5;
  releaseLock(lock);
}
state.Lock{}?
----
application/datalog

main {
  lock = prim.newLock();
  block.acquireLock(lock);
  forkTo afterFork;
  t = 5;
  block.sleep(t);
  releaseLock(lock);
  goto end;
}
afterFork {
  block.acquireLock(lock);
  x5 = 10;
}
end {}
state.Lock{}?
----
application/datalog

main {
  lock = prim.newLock();
  block.acquireLock(lock);
  forkTo afterFork;
  t = 5;
  block.sleep(t);
  releaseLock(lock);
  goto end;
}
afterFork {
  block.acquireLock(lock);
  x5 = 10;
}
end {}
debug.doubleLockHolder{}?
----
application/datalog

main {
  lock1 = prim.newLock();
  lock2 = prim.newLock();
  block.acquireLock(lock1);
  forkTo afterFork;
  t = 5;
  block.sleep(t);
  block.acquireLock(lock2);
}
afterFork {
  block.acquireLock(lock2);
  block.acquireLock(lock1);
}
end {}
issue.Deadlock{}?
----
application/datalog
