.table instr
.table maxTime
.table expr.funcCall
.table expr.funcArg
.table expr.intLit
.table expr.var
.table state.programCounter.init

# time

maxTime{time: 30}.

time{time: T} :-
  maxTime{time: MaxT} &
  range{from: 0, to: MaxT, val: T}.

# === Program Counter ===

state.ProgramCounter{thread: TH, time: T, counter: C, state: St} :-
  state.programCounter.init{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.storeBasic{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.goto{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.gotoIf{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.call{thread: TH, time: T, counter: C, state: St}.

state.programCounter.storeBasic{thread: TH, time: T, counter: C, state: running{}} :-
  state.programCounter.storeBasic.literal{thread: TH, time: T, counter: C, state: running{}} |
  state.programCounter.storeBasic.primitive{thread: TH, time: T, counter: C, state: running{}}.
state.programCounter.storeBasic.literal{thread: TH, time: T, counter: C, state: running{}} :-
  time{time: T} &
  instr{idx: PrevC, op: store{val: Lit}} &
  base.int{a: Lit} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}}.
state.programCounter.storeBasic.primitive{thread: TH, time: T, counter: C, state: running{}} :-
  time{time: T} &
  instr{idx: PrevC, op: store{val: primitive{}}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}}.
# condGoto
state.programCounter.gotoIf{thread: TH, time: T, counter: C, state: St} :-
  state.programCounter.gotoIf.yes{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.gotoIf.no{thread: TH, time: T, counter: C, state: St}.
state.programCounter.gotoIf.yes{thread: TH, time: T, counter: C, state: running{}} :-
  time{time: T} &
  instr{idx: PrevC, op: gotoIf{dest: C, cond: Var}} &
  T = PrevT + 1 &
  state.Var{thread: TH, time: PrevT, var: Var, value: true} &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}}.
state.programCounter.gotoIf.no{thread: TH, time: T, counter: C, state: running{}} :-
  time{time: T} &
  instr{idx: PrevC, op: gotoIf{cond: Var}} &
  T = PrevT + 1 &
  state.Var{thread: TH, time: PrevT, var: Var, value: false} &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}}.
# goto
state.programCounter.goto{thread: TH, time: T, counter: C, state: running{}} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}} &
  T = PrevT + 1 &
  instr{idx: PrevC, op: goto{dest: C}}.

# call
state.programCounter.call{thread: TH, time: T, counter: C, state: St} :-
  state.programCounter.fork{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.call.sleep{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.call.acquireLock{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.call.releaseLock{thread: TH, time: T, counter: C, state: St}.

# fork
state.programCounter.fork{thread: TH, time: T, counter: C, state: St} :-
  state.programCounter.fork.orig{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.fork.new{thread: TH, time: T, counter: C, state: St}.
state.programCounter.fork.orig{thread: TH, time: T, counter: C, state: running{}} :-
  time{time: T} &
  instr{idx: PrevC, op: forkTo{}} &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}} &
  T = PrevT + 1 &
  C = PrevC + 1.
state.programCounter.fork.new{
  thread: TH,
  origThread: PrevTH,
  time: T,
  counter: C,
  state: running{},
} :-
  time{time: T} &
  instr{idx: PrevC, op: forkTo{dest: C}} &
  state.ProgramCounter{thread: PrevTH, time: PrevT, counter: PrevC, state: running{}} &
  T = PrevT + 1 &
  ShiftedT = T + 100 &
  TH = PrevTH + ShiftedT.
# sleep
state.programCounter.call.sleep{thread: TH, time: T, counter: C, state: St} :-
  state.programCounter.timer.init{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.timer.block{thread: TH, time: T, counter: C, state: St} |
  state.programCounter.timer.unblock{thread: TH, time: T, counter: C, state: St}.
state.programCounter.timer.init{
  thread: TH,
  time: T,
  counter: C,
  state: blocked{reason: timer{
    thread: TH,
    start: T,
  }},
  dur: Dur,
} :-
  time{time: T} &
  instr{idx: PrevC, op: store{val: blockingCall{fun: "block.sleep", args: [DurVar]}}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}} &
  state.Var{thread: TH, time: T, var: DurVar, value: Dur}.
# step thread forward in time while blocked
state.programCounter.timer.block{
  thread: TH,
  time: T,
  counter: C,
  state: blocked{reason: timer{
    start: StartT,
    thread: TH,
  }},
  wakeupTime: WT,
} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C, state: blocked{reason: timer{
    start: StartT,
    thread: TH,
  }}} &
  time{time: T} &
  T = PrevT + 1 &
  state.Timer{thread: TH, startTime: StartT, wakeupTime: WT} &
  T < WT.
# wake up thread when it's time to unblock
state.programCounter.timer.unblock{thread: TH, time: T, counter: C, state: running{}} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C, state: blocked{reason: timer{
    start: StartT,
    thread: TH,
  }}} &
  time{time: T} &
  T = PrevT + 1 &
  state.Timer{thread: TH, startTime: StartT, wakeupTime: WT} &
  WT = T.
# acquire lock
state.programCounter.call.acquireLock{thread: TH, time: T, counter: C, state: St, lock: L} :-
  state.programCounter.lock.init{thread: TH, time: T, counter: C, state: St, lock: L} |
  state.programCounter.lock.acquire.block{thread: TH, time: T, counter: C, state: St, lock: L} |
  state.programCounter.lock.acquire.unblock{thread: TH, time: T, counter: C, state: St, lock: L}.
state.programCounter.lock.init{thread: TH, time: T, counter: C, state: St, lock: L} :-
  state.programCounter.lock.acquire.init.held{thread: TH, time: T, counter: C, state: St, lock: L} |
  state.programCounter.lock.acquire.init.open{thread: TH, time: T, counter: C, state: St, lock: L}.
state.programCounter.lock.acquire.init.held{
  thread: TH,
  time: T,
  counter: C,
  state: blocked{reason: lock{id: LockVal}},
  lock: LockVal,
} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C, state: running{}} &
  instr{idx: C, op: store{val: blockingCall{fun: "block.acquireLock", args: [LockVar]}}} &
  state.Var{thread: TH, time: PrevT, var: LockVar, value: LockVal} &
  state.Lock{id: LockVal, state: heldBy{}, time: PrevT} &
  T = PrevT + 1.
state.programCounter.lock.acquire.init.open{
  thread: TH,
  time: T,
  counter: C,
  state: running{},
  lock: LockVal,
} :-
  time{time: T} &
  T = PrevT + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}} &
  instr{idx: PrevC, op: store{val: blockingCall{fun: "block.acquireLock", args: [LockVar]}}} &
  state.Var{thread: TH, time: PrevT, var: LockVar, value: LockVal} &
  state.Lock{id: LockVal, state: open{}, time: PrevT} &
  C = PrevC + 1.
# step forward in time while still blocked on the lock
state.programCounter.lock.acquire.block{
  thread: TH,
  time: T,
  counter: C,
  state: blocked{reason: lock{id: LockVal}},
} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C, state: blocked{reason: lock{id: LockVal}}} &
  T = PrevT + 1 &
  state.Lock{time: PrevT, id: LockVal, state: heldBy{}}.
state.programCounter.lock.acquire.unblock{thread: BlockedThread, time: T, counter: C, state: running{}} :-
  state.ProgramCounter{time: PrevT, counter: PrevC, thread: BlockedThread, state: blocked{reason: lock{id: LockVal}}} &
  instr{idx: PrevC, op: store{fun: "block.acquireLock", args: [LockVar]}} &
  state.Var{thread: BlockedThread, var: LockVar, value: LockVal, time: PrevT} &
  state.Lock{id: LockVal, time: PrevT, state: heldBy{thread: HoldingThread}} &
  state.programCounter.call.releaseLock{time: T, thread: HoldingThread} &
  T = PrevT + 1 &
  C = PrevC + 1.
# release lock
state.programCounter.call.releaseLock{
  thread: TH,
  time: T,
  counter: C,
  state: running{},
  lock: LockVal,
} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC, state: running{}} &
  instr{idx: PrevC, op: store{val: call{fun: "releaseLock", args: [LockVar]}}} &
  state.Var{thread: TH, time: PrevT, var: LockVar, value: LockVal} &
  state.Lock{id: LockVal, state: heldBy{thread: TH}, time: PrevT} &
  T = PrevT + 1 &
  C = PrevC + 1.

# === Var ===

state.Var{thread: TH, time: T, var: Var, value: Val} :-
  state.var.storeInt{thread: TH, time: T, var: Var, value: Val} |
  # TODO: storeString
  state.var.store.call{thread: TH, time: T, var: Var, value: Val} |
  state.var.stay{thread: TH, time: T, var: Var, value: Val}.

state.var.storeInt{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: Val}} &
  base.int{a: Val} &
  T = PrevT + 1.
  
state.var.store.call{thread: TH, time: T, var: Var, value: Val, fun: F} :-
  state.var.store.call.incr{thread: TH, time: T, var: Var, value: Val, fun: F} |
  state.var.store.call.LT{thread: TH, time: T, var: Var, value: Val, fun: F} |
  state.var.store.call.newLock{thread: TH, time: T, var: Var, value: Val, fun: F}.
# incr
state.var.store.call.incr{thread: TH, time: T, var: Var, value: Val, fun: "prim.incr"} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.incr", args: [ArgVar]}}} &
  state.Var{thread: TH, time: PrevT, var: ArgVar, value: ArgVal} &
  Val = ArgVal + 1 &
  T = PrevT + 1.
# less than
state.var.store.call.LT{thread: TH, time: T, var: Var, value: Val, fun: "prim.lt"} :-
  state.var.store.call.LT.yes{thread: TH, time: T, var: Var, value: Val} |
  state.var.store.call.LT.no{thread: TH, time: T, var: Var, value: Val}.
state.var.store.call.LT.yes{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.lt", args: [Arg1Var, Arg2Var]}}} &
  state.Var{thread: TH, time: PrevT, var: Arg1Var, value: Arg1Val} &
  state.Var{thread: TH, time: PrevT, var: Arg2Var, value: Arg2Val} &
  Arg1Val < Arg2Val &
  Val = true &
  T = PrevT + 1.
state.var.store.call.LT.no{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.lt", args: [Arg1Var, Arg2Var]}}} &
  state.Var{thread: TH, time: PrevT, var: Arg1Var, value: Arg1Val} &
  state.Var{thread: TH, time: PrevT, var: Arg2Var, value: Arg2Val} &
  Arg1Val >= Arg2Val &
  Val = false &
  T = PrevT + 1.
state.var.store.call.fork.orig{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: call{fun: "fork"}}} &
  Val = false &
  T = PrevT + 1.
# newLock
state.var.store.call.newLock{thread: TH, time: T, var: Var, value: Val, fun: "prim.newLock"} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.newLock"}}} &
  T = PrevT + 1 &
  Val = created{thread: TH, time: T}.

# == stay ==
# propagate forward in time the values of variables that
# aren't being changed at this timestep
state.var.stay{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.fork{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.goto{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.gotoIf{thread: TH, time: T, var: Var, value: PrevVal}.
# store & increment
state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: store{var: OtherVar}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  OtherVar != Var.
# fork
state.var.stay.fork{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.fork.orig{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.fork.new{thread: TH, time: T, var: Var, value: PrevVal}.
state.var.stay.fork.orig{thread: OrigTH, time: T, var: Var, value: PrevVal} :-
  state.programCounter.fork.new{origThread: OrigTH, time: T} &
  T = PrevT + 1 &
  state.Var{thread: OrigTH, time: PrevT, var: Var, value: PrevVal}.
state.var.stay.fork.new{thread: NewTH, time: T, var: Var, value: Val} :-
  state.programCounter.fork.new{origThread: OrigTH, thread: NewTH, time: T} &
  T = PrevT + 1 &
  state.Var{thread: OrigTH, time: PrevT, var: Var, value: Val}.
# goto
state.var.stay.goto{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: goto{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.
# gotoIf
state.var.stay.gotoIf{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: gotoIf{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.

# === Timer ===

state.Timer{thread: TH, startTime: T, wakeupTime: WT} :-
  state.programCounter.timer.init{thread: TH, time: T, counter: C, state: blocked{}, dur: Dur} &
  WT = T + Dur.

# === Lock ===

state.Lock{id: I, state: St, time: T} :-
  state.lock.created{id: I, state: St, time: T} |
  state.lock.acquired{id: I, state: St, time: T} |
  state.lock.stay{id: I, state: St, time: T} |
  state.lock.released{id: I, state: St, time: T}.
state.lock.stay{id: I, state: St, time: T} :-
  state.lock.stay.open{id: I, state: St, time: T} |
  state.lock.stay.held{id: I, state: St, time: T}.
state.lock.created{id: created{thread: TH, time: T}, state: open{}, time: T} :-
  state.var.store.call.newLock{thread: TH, time: T, var: Var}.
state.lock.acquired{id: I, state: St, time: T} :-
  state.lock.acquired.open{id: I, state: St, time: T} |
  state.lock.acquired.unblocked{id: I, state: St, time: T}.
state.lock.acquired.open{id: I, state: heldBy{thread: TH}, time: T} :-
  state.programCounter.lock.acquire.init.open{
    thread: TH, time: T, counter: C, state: running{}, lock: I,
  }.
state.lock.acquired.unblocked{id: I, state: St, time: T} :-
  state.programCounter.lock.acquire.unblock{thread: TH, time: T, counter: C, state: St, lock: I}.
state.lock.stay.open{id: I, state: open{}, time: T} :-
  state.ProgramCounter{time: T} &
  state.Lock{time: PrevT, id: I, state: open{}} &
  T = PrevT + 1 &
  !state.programCounter.call.acquireLock{time: T, lock: I}.
state.lock.stay.held{id: I, state: heldBy{thread: TH}, time: T} :-
  state.ProgramCounter{time: T, thread: TH} &
  state.Lock{time: PrevT, id: I, state: heldBy{thread: TH}} &
  T = PrevT + 1 &
  !state.programCounter.call.releaseLock{time: T, lock: I}.
state.lock.released{id: I, state: open{}, time: T} :-
  state.programCounter.call.releaseLock{time: T, lock: I}.

# state.lockTransfer??

# === debug ===

debug.instrAtTime{time: T, thread: TH, counter: C, instr: I} :-
  state.ProgramCounter{time: T, thread: TH, counter: C} &
  instr{idx: C, op: I}.

# TODO: these should be ICs

# program counter should be unique for each (thread, time)
debug.doubleProgramCounter{time: T, thread: TH, counter1: C1, counter2: C2} :-
  state.programCounter.gotoIf{time: T, thread: TH, counter: C1} &
  state.programCounter.gotoIf{time: T, thread: TH, counter: C2} &
  C1 != C2.

# var value should be unique for each (var, thread, time)
debug.doubleVar{var: Var, time: T, thread: TH, val1: Val1, val2: Val2} :-
  state.Var{var: Var, value: Val1, time: T, thread: TH} &
  state.Var{var: Var, value: Val2, time: T, thread: TH} &
  Val1 != Val2.
debug.doubleVar.forkNew{var: Var, time: T, thread: TH, val1: Val1, val2: Val2} :-
  state.var.stay.fork.new{var: Var, value: Val1, time: T, thread: TH} &
  state.var.stay.fork.new{var: Var, value: Val2, time: T, thread: TH} &
  Val1 != Val2.
debug.doubleVar.forkOrig{var: Var, time: T, thread: TH, val1: Val1, val2: Val2} :-
  state.var.stay.fork.orig{var: Var, value: Val1, time: T, thread: TH} &
  state.var.stay.fork.orig{var: Var, value: Val2, time: T, thread: TH} &
  Val1 != Val2.
debug.doubleVar.store.call{var: Var, time: T, thread: TH, val1: Val1, val2: Val2, fun: F} :-
  state.var.store.call{var: Var, value: Val1, time: T, thread: TH, fun: F} &
  state.var.store.call{var: Var, value: Val2, time: T, thread: TH, fun: F} &
  Val1 != Val2.

# lock holder should be unique for each (lock, time)
debug.doubleLockHolder{id: I, time: T, thread1: TH1, thread2: TH2} :-
  state.Lock{id: I, state: heldBy{thread: TH2}, time: T} &
  state.Lock{id: I, state: heldBy{thread: TH1}, time: T} &
  TH1 < TH2.

# === Viz ===

.table internal.visualization

# internal.visualization{
#   name: "Time Ticker",
#   spec: ticker{},
# }.

internal.visualization{
  name: "Program Counter over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "counter", type: "quantitative"},
      color: mapping{field: "thread"}
    },
    query: state.ProgramCounter{}
  }
}.

viz.threadVar{time: T, tv: [TH, V], value: Val} :-
  state.Var{thread: TH, time: T, var: V, value: Val}.

# TODO: another encoding channel for thread
internal.visualization{
  name: "Variables Over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "value", type: "quantitative"},
      color: mapping{field: "tv"}
    },
    query: viz.threadVar{}
  }
}.

viz.message{fromTick: FromTick, toTick: ToTick} :-
  viz.spawnMessage{fromTick: FromTick, toTick: ToTick} |
  viz.continueMessage{fromTick: FromTick, toTick: ToTick}.
viz.spawnMessage{
  fromTick: tick{time: FromT, place: FromTH},
  toTick: tick{time: ToT, place: ToTH}
} :-
  state.programCounter.fork.new{thread: ToTH, time: ToT, origThread: FromTH} &
  ToT = FromT + 1.
viz.continueMessage{
  fromTick: tick{time: PrevT, place: TH},
  toTick: tick{time: T, place: TH}
} :-
  state.ProgramCounter{thread: TH, time: PrevT} &
  state.ProgramCounter{thread: TH, time: T} &
  PrevT = T + 1.
viz.tickColor{tick: T, color: C} :-
  viz.runningColor{tick: T, color: C} |
  viz.blockedColor{tick: T, color: C}.
viz.runningColor{tick: tick{time: T, place: TH}, color: "red"} :-
  state.ProgramCounter{thread: TH, time: T, state: running{}}.
viz.blockedColor{tick: tick{time: T, place: TH}, color: "grey"} :-
  state.ProgramCounter{thread: TH, time: T, state: blocked{}}.

internal.visualization{
  name: "Spawning Sequence",
  spec: sequence{
    actors: state.ProgramCounter{thread: ID},
    messages: viz.message{fromTick: FromTick, toTick: ToTick},
    tickColor: viz.tickColor{tick: Tick, color: Color},
  },
}.

# insertion

state.programCounter.init{thread: 1, time: 1, counter: 0, state: running{}}.
