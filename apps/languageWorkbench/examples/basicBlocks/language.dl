# === highlight ===

hl.Segment{type: T, span: S, highlight: H} :-
  hl.keyword{type: T, span: S, highlight: H} |
  hl.segmentDefn{type: T, span: S, highlight: H} |
  hl.segmentDefnHL{type: T, span: S, highlight: H} |
  hl.segmentUsage{type: T, span: S, highlight: H} |
  hl.segmentUsageHL{type: T, span: S, highlight: H} |
  hl.segmentFuncName{type: T, span: S, highlight: H} |
  hl.segmentVar{type: T, span: S, highlight: H} |
  hl.segmentInt{type: T, span: S, highlight: H} |
  hl.segmentString{type: T, span: S, highlight: H}.

hl.keyword{type: "keyword", span: S, highlight: false} :-
  ast.gotoKW{span: S}.

hl.segmentVar{type: "var", span: S, highlight: false} :-
  ast.ident{parentID: ParamsID, span: S} &
  ast.params{id: ParamsID}.

hl.segmentFuncName{type: "funcName", span: S, highlight: false} :-
  ast.rvalue{id: RValueID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.ident{parentID: CallID, span: S}.

# TODO: only highlight if used
hl.segmentDefn{type: "defn", span: S, highlight: false} :-
  scope.Defn{span: S}.
hl.segmentDefnHL{type: "defn", span: S, highlight: true} :-
  ide.CurrentUsage{defnLoc: S} &
  scope.Defn{span: S}.

hl.segmentUsage{type: "usage", span: S, highlight: false} :-
  scope.Usage{usageLoc: S}.
hl.segmentUsageHL{type: "usage", span: S, highlight: true} :-
  ide.CurrentUsage{usageLoc: S}.

hl.segmentInt{type: "int", span: S, highlight: false} :-
  ast.int{span: S}.
hl.segmentString{type: "string", span: S, highlight: false} :-
  ast.string{span: S}.

# === Scope ===

scope.Scope{id: InstrID} :-
  ast.instr{id: InstrID}.

scope.Parent{childID: ChildID, parentID: ParentID} :-
  ast.instr{id: ChildID, parentID: BlockID, idx: ChildIdx} &
  ast.instr{id: ParentID, parentID: BlockID, idx: ParentIdx} &
  ChildIdx > ParentIdx.

# this var defined at this node
scope.Defn{scopeID: InstrID, span: S, name: N} :-
  ast.instr{id: InstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: InstrID} &
  ast.ident{parentID: ValueInstrID, text: N, span: S}.
# TODO: block labels

# TODO: say which kind of var it's trying to use
# i.e. value vs. label
scope.Var{scopeID: InstrID, name: N, span: S} :-
  ast.ident{parentID: ParamsID, text: N, span: S} &
  ast.params{id: ParamsID, parentID: CallID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.rvalue{id: RValueID, parentID: ValueInstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: InstrID}.

scope.Placeholder{span: S, scopeID: I} :-
  ast.placeholder{id: PlaceholderID, parentID: ParamsID, span: S} &
  ast.params{id: ParamsID, parentID: CallID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.rvalue{id: RValueID, parentID: ValueInstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: I}.

# === viz ===

## TODO: not sure where this should live...
# ide.jump{from: BF, to: BT} :-
#   defn.goto{blockID: BlockID, to: BT} &
#   defn.block{id: BlockID, name: BF}.

# internal.visualization{
#   name: "Jumps",
#   spec: graphviz{
#     nodes: "defn.block{name: ID}",
#     edges: "ide.jump{from: From, to: To}"
#   }
# }.
