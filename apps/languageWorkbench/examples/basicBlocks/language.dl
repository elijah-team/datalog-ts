# === highlight ===

hl.Segment{type: T, span: S, highlight: H} :-
  hl.keyword{type: T, span: S, highlight: H} |
  hl.segmentDefn{type: T, span: S, highlight: H} |
  hl.segmentDefnHL{type: T, span: S, highlight: H} |
  hl.segmentUsage{type: T, span: S, highlight: H} |
  hl.segmentUsageHL{type: T, span: S, highlight: H} |
  hl.segmentFuncName{type: T, span: S, highlight: H} |
  hl.segmentVar{type: T, span: S, highlight: H} |
  hl.segmentInt{type: T, span: S, highlight: H} |
  hl.segmentString{type: T, span: S, highlight: H}.

hl.keyword{type: "keyword", span: S, highlight: false} :-
  ast.gotoKW{span: S}.

hl.segmentVar{type: "var", span: S, highlight: false} :-
  ast.ident{parentID: ParamsID, span: S} &
  ast.params{id: ParamsID}.

hl.segmentFuncName{type: "funcName", span: S, highlight: false} :-
  ast.rvalue{id: RValueID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.ident{parentID: CallID, span: S}.

# TODO: only highlight if used
hl.segmentDefn{type: "defn", span: S, highlight: false} :-
  scope.Defn{span: S}.
hl.segmentDefnHL{type: "defn", span: S, highlight: true} :-
  ide.CurrentUsage{defnLoc: S} &
  scope.Defn{span: S}.

hl.segmentUsage{type: "usage", span: S, highlight: false} :-
  scope.Usage{usageLoc: S}.
hl.segmentUsageHL{type: "usage", span: S, highlight: true} :-
  ide.CurrentUsage{usageLoc: S}.

hl.segmentInt{type: "int", span: S, highlight: false} :-
  ast.int{span: S}.
hl.segmentString{type: "string", span: S, highlight: false} :-
  ast.string{span: S}.

# === Scope ===

scope.Scope{id: InstrID} :-
  ast.instr{id: InstrID}.

scope.Parent{childID: ChildID, parentID: ParentID} :-
  scope.parentWithinBlock{childID: ChildID, parentID: ParentID} |
  scope.parentGlobal{childID: ChildID, parentID: ParentID}.
# each instr creates a scope for the instrs below it
scope.parentWithinBlock{childID: ChildID, parentID: ParentID} :-
  ast.instr{id: ChildID, parentID: BlockID, idx: ChildIdx} &
  ast.instr{id: ParentID, parentID: BlockID, idx: ParentIdx} &
  ChildIdx > ParentIdx.
# global is parent of all scopes
scope.parentGlobal{parentID: "global", childID: ChildID} :-
  ast.instr{id: ChildID}.

# this var defined at this node
scope.Defn{scopeID: I, span: S, name: N, kind: K} :-
  scope.defnValue{scopeID: I, span: S, name: N, kind: K} |
  scope.defnLabel{scopeID: I, span: S, name: N, kind: K}.
# definitions of value variables
scope.defnValue{scopeID: InstrID, span: S, name: N, kind: "value"} :-
  ast.instr{id: InstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: InstrID} &
  ast.ident{parentID: ValueInstrID, text: N, span: S}.
# definitions of label variables
scope.defnLabel{scopeID: "global", span: S, name: N, kind: "label"} :-
  ast.label{parentID: BlockID, span: S, text: N} &
  ast.block{id: BlockID}.

# TODO: say which kind of var it's trying to use
# i.e. value vs. label
scope.Var{scopeID: InstrID, name: N, span: S, kind: K} :-
  scope.varValue{scopeID: InstrID, name: N, span: S, kind: "value"} |
  scope.varLabel{scopeID: InstrID, name: N, span: S, kind: "label"}.
# variables that refer to values
scope.varValue{scopeID: InstrID, name: N, span: S, kind: K} :-
  ast.ident{parentID: ParamsID, text: N, span: S} &
  ast.params{id: ParamsID, parentID: CallID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.rvalue{id: RValueID, parentID: ValueInstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: InstrID}.
# variables that refer to labels
scope.varLabel{scopeID: InstrID, name: N, span: S, kind: K} :-
  ast.label{id: LabelID, parentID: GotoID, text: N, span: S} &
  ast.gotoInstr{id: GotoID, parentID: InstrID}.

scope.Placeholder{span: S, scopeID: I, kind: K} :-
  scope.placeholderValue{span: S, scopeID: I, kind: K} |
  scope.placeholderLabel{span: S, scopeID: I, kind: K}.
scope.placeholderValue{span: S, scopeID: I, kind: "value"} :-
  ast.Placeholder{id: PlaceholderID, parentID: ParamsID, span: S} &
  ast.params{id: ParamsID, parentID: CallID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.rvalue{id: RValueID, parentID: ValueInstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: I}.
scope.placeholderLabel{span: S, scopeID: I, kind: "label"} :-
  ast.Placeholder{id: PlaceholderID, parentID: GotoInstrID, span: S} &
  ast.gotoInstr{id: GotoInstrID, parentID: I}.

# === viz ===

## TODO: not sure where this should live...
# ide.jump{from: BF, to: BT} :-
#   defn.goto{blockID: BlockID, to: BT} &
#   defn.block{id: BlockID, name: BF}.

# internal.visualization{
#   name: "Jumps",
#   spec: graphviz{
#     nodes: "defn.block{name: ID}",
#     edges: "ide.jump{from: From, to: To}"
#   }
# }.
