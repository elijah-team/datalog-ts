# === highlight ===

hl.Segment{type: T, span: S, highlight: H} :-
  hl.keyword{type: T, span: S, highlight: H} |
  hl.segmentDefn{type: T, span: S, highlight: H} |
  hl.segmentDefnHL{type: T, span: S, highlight: H} |
  hl.segmentUsage{type: T, span: S, highlight: H} |
  hl.segmentUsageHL{type: T, span: S, highlight: H} |
  hl.segmentFuncName{type: T, span: S, highlight: H}.

hl.keyword{type: "keyword", span: S, highlight: false} :-
  ast.gotoKW{span: S}.

hl.varDefn{span: S} :-
  defn.block{labelSpan: S} |
  defn.ssaVar{span: S}.

hl.segmentFuncName{type: "funcName", span: S, highlight: false} :-
  ast.rvalue{id: RValueID} &
  ast.call{id: CallID, parentID: RValueID} &
  ast.ident{parentID: CallID, span: S}.

hl.segmentDefn{type: "defn", span: S, highlight: false} :-
  hl.varDefn{span: S}.
hl.segmentDefnHL{type: "defn", span: S, highlight: true} :-
  ide.CurrentUsage{defnLoc: S} &
  hl.varDefn{span: S}.

hl.segmentUsage{type: "usage", span: S, highlight: false} :-
  ide.Usage{usageLoc: S}.
hl.segmentUsageHL{type: "usage", span: S, highlight: true} :-
  ide.CurrentUsage{usageLoc: S}.

# === defn ===

defn.goto{blockID: BlockID, instrID: InstrID, to: ToName, labelSpan: S} :-
  ast.ident{text: ToName, parentID: LabelID} &
  ast.label{id: LabelID, parentID: GotoInstrID, span: S} &
  ast.gotoInstr{id: GotoInstrID, parentID: InstrID} &
  ast.instr{id: InstrID, parentID: BlockID}.

# TODO: refactor this into a generic "rvalue" concept? idk
defn.ssaVar{instrID: InstrID, span: S, name: N} :-
  ast.instr{id: InstrID} &
  ast.valueInstr{id: ValueInstrID, parentID: InstrID} &
  ast.ident{parentID: ValueInstrID, text: N, span: S}.

defn.block{id: BlockID, name: N, labelSpan: S} :-
  ast.block{id: BlockID} &
  ast.label{id: LabelID, parentID: BlockID} &
  ast.ident{parentID: LabelID, text: N, span: S}.

# === Scope ===

scope.item{id: I, type: T, name: N} :-
  scope.itemVar{id: I, type: T, name: N} |
  scope.itemLabel{id: I, type: T, name: N}.

scope.itemVar{id: I, type: "var", name: N} :-
  defn.ssaVar{instrID: InstrID, name: N} &
  ast.instr{id: InstrID, parentID: BlockID, idx: DefnIdx} &
  ast.instr{id: I, parentID: BlockID, idx: CurrentIdx} &
  DefnIdx <= CurrentIdx.

scope.itemLabel{id: I, type: "label", name: N} :-
  ast.instr{id: I} &
  defn.block{name: N}.

# === IDE ===

ide.Usage{definitionLoc: DL, usageLoc: UL, name: N} :-
  defn.block{labelSpan: DL, name: N} &
  defn.goto{labelSpan: UL, to: N}.

ide.jump{from: BF, to: BT} :-
  defn.goto{blockID: BlockID, to: BT} &
  defn.block{id: BlockID, name: BF}.


# all usages of the var the cursor is currently on,
# with definition location.
ide.CurrentUsage{defnLoc: DL, usageLoc: UL} :-
  ide.CurrentUsageDefn{defnLoc: DL, usageLoc: UL} |
  ide.CurrentUsageUsage{defnLoc: DL, usageLoc: UL} |
  ide.CurrentUsageUsageIndirect{defnLoc: DL, usageLoc: UL} & DL != "builtin".
ide.CurrentUsageDefn{defnLoc: span{from: FIdx, to: TIdx}, usageLoc: UL} :-
  ide.Usage{definitionLoc: span{from: FIdx, to: TIdx}, usageLoc: UL} &
  ide.Cursor{idx: CIdx} &
  FIdx <= CIdx & CIdx <= TIdx.
ide.CurrentUsageUsage{defnLoc: DL, usageLoc: span{from: FIdx, to: TIdx}} :-
  ide.Usage{definitionLoc: DL, usageLoc: span{from: FIdx, to: TIdx}} &
  ide.Cursor{idx: CIdx} &
  FIdx <= CIdx & CIdx <= TIdx.
ide.CurrentUsageUsageIndirect{defnLoc: DL, usageLoc: UL} :-
  ide.CurrentUsageUsage{defnLoc: DL} &
  ide.Usage{definitionLoc: DL, usageLoc: UL}.

# === viz ===

internal.visualization{
  name: "Jumps",
  spec: graphviz{
    nodes: "defn.block{name: ID}",
    edges: "ide.jump{from: From, to: To}"
  }
}.
