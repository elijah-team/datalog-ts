.table input.char
.table input.next

.table grammar.rule
.table grammar.stateNode
.table grammar.refEdge
.table grammar.charLiteralEdge

# === grammar ===

# main = foo
grammar.rule{name: "main", from: 0, to: 2}.
grammar.stateNode{id: 0}.
grammar.refEdge{from: 0, to: 1, ref: "foo"}.
grammar.stateNode{id: 1}.
grammar.refEdge{from: 1, to: 2, ref: "bar"}.
grammar.stateNode{id: 2}.

# foo = "foo".
grammar.rule{name: "foo", from: 3, to: 6}.
grammar.stateNode{id: 3}.
grammar.charLiteralEdge{from: 3, to: 4, val: "f"}.
grammar.stateNode{id: 4}.
grammar.charLiteralEdge{from: 4, to: 5, val: "o"}.
grammar.stateNode{id: 5}.
grammar.charLiteralEdge{from: 5, to: 6, val: "o"}.
grammar.stateNode{id: 6}.

# bar = "bar".
grammar.rule{name: "bar", from: 7, to: 10}.
grammar.stateNode{id: 7}.
grammar.charLiteralEdge{from: 7, to: 8, val: "b"}.
grammar.stateNode{id: 8}.
grammar.charLiteralEdge{from: 8, to: 9, val: "a"}.
grammar.stateNode{id: 9}.
grammar.charLiteralEdge{from: 9, to: 10, val: "r"}.
grammar.stateNode{id: 10}.


# === interpreter ===

parse.Complete{} :-
  parse.State{char: C} &
  input.next{from: C, to: -2}.

parse.State{state: S, char: C} :-
  parse.stateStep{to: st{state: S, char: C}}.

# parse.statePath{from: From, to: To} :-
#   parse.stateStep{from: From, to: To} |
#   parse.stateStep{from: From, to: Between} &
#   parse.statePath{from: Between, to: To}.

# state step

parse.stateStep{from: From, to: To} :-
  parse.sameState{from: From, to: To} |
  parse.initialStateStep{from: From, to: To} |
  parse.matchChar{from: From, to: To} |
  parse.callRule{from: From, to: To} |
  parse.returnFromRule{from: From, to: To}.

parse.sameState{
  from: st{state: S, char: C},
  to: st{state: S, char: C}
} :-
  parse.State{state: S, char: C}.
parse.initialStateStep{
  from: st{state: -1, char: -1},
  to: st{state: S, char: C}
} :-
  grammar.rule{name: "main", from: S} &
  input.next{from: -1, to: C}.

parse.matchChar{
  from: st{state: FromS, char: FromC},
  to: st{state: ToS, char: ToC}
} :-
  parse.State{state: FromS, char: FromC} &
  grammar.charLiteralEdge{from: FromS, to: ToS, val: V} &
  input.char{id: FromC, val: V} &
  input.next{from: FromC, to: ToC}.

parse.callRule{
  from: st{state: FromS, char: FromC},
  to: st{state: ToS, char: ToC}
} :-
  parse.State{state: FromS, char: FromC} &
  grammar.refEdge{from: FromS, ref: Rule} &
  grammar.rule{name: Rule, from: ToS} &
  ToC = FromC.

parse.returnFromRule{
  from: st{state: FromS, char: FromC},
  to: st{state: ToS, char: ToC}
} :-
  parse.State{state: SBeforeRef, char: CStart} &
  grammar.refEdge{from: SBeforeRef, to: ToS, ref: Rule} &
  grammar.rule{name: Rule, from: SRuleStart, to: FromS} &
  parse.State{state: FromS, char: ToC} &
  FromC = ToC.

# building rule tree

parse.ruleMatch{rule: Rule, span: span{from: CStart, to: CEnd}} :-
  grammar.rule{name: Rule, from: SRuleStart, to: SRuleEnd} &
  parse.State{state: SRuleStart, char: CStart} &
  parse.State{state: SRuleEnd, char: CEnd}.

parse.ruleMatchParent{
  child: match{rule: ChildRule, span: span{from: ChildStartCh, to: ChildEndCh}},
  parent: match{rule: ParentRule, span: span{from: ParentStartCh, to: ParentEndCh}},
} :-
  parse.ruleMatch{rule: ParentRule, span: span{from: ParentStartCh, to: ParentEndCh}} &
  parse.ruleMatch{rule: ChildRule, span: span{from: ChildStartCh, to: ChildEndCh}} &
  grammar.rule{name: ParentRule, from: ParentStartSt} &
  grammar.rule{name: ChildRule, from: ChildStartSt} &
  grammar.refEdge{from: RefSt, ref: ChildRule} &
  grammar.stateReachable{from: ParentStartSt, to: RefSt} &
  parse.State{state: RefSt, char: ChildStartCh} &
  parse.stateStep{
    from: st{state: ParentStartSt, char: ParentStartCh},
    to: st{state: ChildStartSt, char: ChildStartCh},
  }.

# === Deriving facts about the grammar ===

grammar.ruleRef{from: FromRule, to: ToRule} :-
  grammar.rule{name: FromRule, from: StartSt} &
  grammar.stateReachable{from: StartSt, to: RefSt} &
  grammar.refEdge{from: RefSt, ref: ToRule}.

grammar.stateReachable{from: StateFrom, to: StateTo} :-
  grammar.stateDirectlyReachable{from: StateFrom, to: StateTo} |
  grammar.stateDirectlyReachable{from: StateFrom, to: StateBetween} &
  grammar.stateReachable{from: StateBetween, to: StateTo}.

grammar.stateDirectlyReachable{from: StateFrom, to: StateTo} :-
  grammar.charLiteralEdge{from: StateFrom, to: StateTo} |
  grammar.refEdge{from: StateFrom, to: StateTo} |
  grammar.stateNode{id: StateFrom} &
  StateTo = StateFrom.

# === input ===

input.char{id: 0, val: "f"}.
input.char{id: 1, val: "o"}.
input.char{id: 2, val: "o"}.
input.char{id: 3, val: "b"}.
input.char{id: 4, val: "a"}.
input.char{id: 5, val: "r"}.

input.next{from: -1, to: 0}.
input.next{from: 0, to: 1}.
input.next{from: 1, to: 2}.
input.next{from: 2, to: 3}.
input.next{from: 3, to: 4}.
input.next{from: 4, to: 5}.
input.next{from: 5, to: -2}.
