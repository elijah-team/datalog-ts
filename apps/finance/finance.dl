.table contract.And
.table contract.Payment
.table contract.Delay
.table contract.Contract

timeWindow{time: T} :-
  range{from: 0, to: 100, val: T}.

# Contract Rules

contract.InCompliance{contractID: I, time: T} :-
  timeWindow{time: T} &
  contract.Contract{id: I} &
  contract.parent{id: N, parentID: I} &
  contract.nodeInCompliance{id: N, time: T}.

contract.nodeInCompliance{id: I, time: T} :-
  timeWindow{time: T} &
  andInCompliance{id: I, time: T} |
  delayInCompliance{id: I, time: T} |
  paymentInCompliance{id: I, time: T}.

andInCompliance{id: I, time: T} :-
  timeWindow{time: T} &
  contract.And{id: I} &
  childrenInCompliance{parentID: I, count: C1, time: T} &
  numChildren{parentID: I, count: C2} &
  C1 = C2.
delayInCompliance{id: I, time: T} :-
  timeWindow{time: T} &
  contract.Delay{id: I, duration: D} &
  contract.parent{parentID: I, id: C} &
  LaterT = T + D &
  contract.nodeInCompliance{id: C, time: LaterT}.
# TODO: on or before T?
paymentInCompliance{id: I, time: T} :-
  timeWindow{time: T} &
  contract.Payment{id: I, from: From, to: To, amount: A} &
  contract.member{contractID: CID, nodeID: I} &
  payment{contractID: CID, from: From, to: To, amount: A, time: PaymentT} &
  PaymentT <= T.

childrenInCompliance{parentID: P, count: I, time: T} :-
  count[P, I: childInCompliance{id: I, parentID: P, time: T}].
childInCompliance{id: I, parentID: P, time: T} :-
  timeWindow{time: T} &
  contract.parent{id: I, parentID: P} &
  contract.nodeInCompliance{id: I, time: T}.

numChildren{parentID: P, count: I} :-
  count[P, I: contract.parent{id: I, parentID: P}].

# tree structure

contract.node{id: A, parentID: B, display: C} :-
  rootNode{id: A, parentID: B, display: C} |
  contractNode{id: A, parentID: B, display: C} |
  paymentNode{id: A, parentID: B, display: C} |
  andNode{id: A, parentID: B, display: C} |
  delayNode{id: A, parentID: B, display: C}.
rootNode{id: "root", parentID: -1, display: root{}}.
contractNode{id: I, parentID: "root", display: [I, contract{name: N}]} :-
  contract.Contract{id: I, name: N}.
andNode{id: I, parentID: P, display: [I, and{}]} :-
  contract.And{id: I, parentID: P}.
delayNode{id: I, parentID: P, display: [I, delay{duration: D}]} :-
  contract.Delay{id: I, parentID: P, duration: D}.
paymentNode{id: I, parentID: P, display: [I, payment{from: F, to: T, amount: A}]} :-
  contract.Payment{id: I, parentID: P, from: F, to: T, amount: A}.

contract.parent{id: I, parentID: P} :-
  contract.And{id: I, parentID: P} |
  contract.Delay{id: I, parentID: P} |
  contract.Payment{id: I, parentID: P}.

# node membership in contracts
contract.ancestor{ancestor: I, descendant: N} :-
  contract.parent{parentID: I, id: N} |
  contract.parent{parentID: B, id: N} &
  contract.ancestor{ancestor: I, descendant: B}.
contract.member{contractID: I, nodeID: N} :-
  contract.Contract{id: I} &
  contract.ancestor{ancestor: I, descendant: N}.

# Viz

internal.visualization{
  name: "Contracts",
  spec: tree{
    nodes: contract.node{id: ID, parentID: ParentID, display: Display},
    rootTerm: -1,
    sortChildren: false
  }
}.

paymentHop{
  from: tick{time: T, place: FP},
  to: tick{time: T, place: TP},
} :-
  payment{from: FP, to: TP, time: T}.

internal.visualization{
  name: "Payments",
  spec: sequence{
    actors: contract.Party{name: ID},
    messages: paymentHop{from: FromTick, to: ToTick},
  }
}.

internal.visualization{
  name: "Contracts Slider",
  spec: paramSlider{
    var: T,
    min: 0,
    max: 100,
    inner: tableEditor{
      query: contract.nodeInCompliance{time: T},
      new: []
    }
  },
}.

# TODO: due date
owe{creditor: C, debtor: D, amount: A, contractID: CID} :-
  contract.Payment{id: N, from: D, to: C, amount: A} &
  !payment{from: D, to: C, amount: A, countractID: CID} &
  contract.member{contractID: CID, nodeID: N}.

# TODO: fix aggregation syntax
balance{creditor: C, debtor: D, amount: A} :-
  sum[C, D, A: owe{creditor: C, debtor: D, amount: A}].

# Example contract

# TODO: parameterize
contract.Contract{id: 1, name: "loan"}.
contract.Party{contractID: 1, name: "Alice"}.
contract.Party{contractID: 1, name: "Bob"}.
contract.And{id: 2, parentID: 1}.
contract.Payment{id: 3, parentID: 2, from: "Alice", to: "Bob", amount: 100}.
contract.Delay{id: 4, parentID: 2, duration: 30}.
contract.Payment{id: 5, parentID: 4, from: "Bob", to: "Alice", amount: 110}.

contract.Contract{id: 6, name: "loan"}.
contract.Party{contractID: 6, name: "Alice"}.
contract.Party{contractID: 6, name: "Bob"}.
contract.And{id: 7, parentID: 6}.
contract.Payment{id: 8, parentID: 7, from: "Alice", to: "Bob", amount: 100}.
contract.Delay{id: 9, parentID: 7, duration: 30}.
contract.Payment{id: 10, parentID: 9, from: "Bob", to: "Alice", amount: 110}.

payment{contractID: 1, from: "Alice", to: "Bob", amount: 100, time: 0}.
# payment{contractID: 1, from: "Bob", to: "Alice", amount: 110, time: 30}.
