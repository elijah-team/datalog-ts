.table internal.visualization
.table input.char
.table input.next
.table grammar.edge
.table grammar.unlabeledEdge
.table grammar.refEdge
.table grammar.charRangeEdge
.table grammar.node
.table grammar.ruleMarker

parse.path{fromNode: N1, toNode: N3, startChar: C1, endChar: C3} :-
  parse.edgeMatch{fromNode: N1, toNode: N3, startChar: C1, endChar: C3} |
  parse.path{fromNode: N1, toNode: N2, startChar: C1, endChar: C2} &
  parse.edgeMatch{fromNode: N2, toNode: N3, startChar: C2, endChar: C3}.

parse.edgeMatch{fromNode: N1, toNode: N3, startChar: C1, endChar: C4} :-
  parse.charMatch{from: N1, to: N3, startChar: C1, endChar: C4}
  |
  parse.ruleMatch{fromNode: N1, toNode: N3, startChar: C1, endChar: C4}
  |
  parse.unlabelledEdgeMatch{fromNode: N1, toNode: N3, startChar: C1, endChar: C4}.

parse.unlabelledEdgeMatch{fromNode: N1, toNode: N2, startChar: C1, endChar: C2} :-
  parse.unlabeledEdgeMatch1{fromNode: N1, toNode: N2, startChar: C1, endChar: C2} |
  parse.unlabeledEdgeMatch2{fromNode: N1, toNode: N2, startChar: C1, endChar: C2}.

parse.unlabeledEdgeMatch1{fromNode: N1, toNode: N2, startChar: C1, endChar: C1} :-
  grammar.unlabeledEdge{from: N1, to: N2} &
  parse.path{fromNode: N2, toNode: N3, startChar: C1, endChar: C2}.

parse.unlabeledEdgeMatch2{fromNode: N2, toNode: N3, startChar: C2, endChar: C2} :-
  grammar.unlabeledEdge{from: N2, to: N3} &
  parse.path{fromNode: N1, toNode: N2, startChar: C1, endChar: C2}.

parse.charMatch{from: N1, to: N2, startChar: C1, endChar: C2} :-
  grammar.edge{from: N1, to: N2, label: C} &
  input.char{id: C1, char: C} &
  input.next{left: C1, right: C2}
  |
  grammar.charRangeEdge{fromChar: FC, toChar: TC, from: N1, to: N2} &
  input.char{id: C1, char: C} &
  FC <= C &
  C <= TC &
  input.next{left: C1, right: C2}.

parse.ruleMatch{fromNode: N1, toNode: N4, startChar: C1, endChar: C4, ruleName: R} :-
  grammar.refEdge{fromID: N1, toID: N4, ruleName: R} &
  parse.rulePath{ruleName: R, startChar: C1, endChar: C4}.

parse.rulePath{ruleName: R, startChar: CS, endChar: CE} :-
  grammar.ruleMarker{name: R, startID: NS, endID: NE} &
  parse.path{fromNode: NS, toNode: NE, startChar: CS, endChar: CE}.

parse.fullMatch{} :-
  parse.rulePath{ruleName: "main", startChar: CS, endChar: -2} &
  input.next{left: -1, right: CS}.

# viz

grammarViz.edge{from: F, to: T, label: L} :-
  grammarViz.normalEdge{from: F, to: T, label: L} |
  grammarViz.unlabeledEdge{from: F, to: T, label: L} |
  grammarViz.refEdge{from: F, to: T, label: L} |
  grammarViz.charRangeEdge{from: F, to: T, label: L}.

grammarViz.normalEdge{from: F, to: T, label: L} :-
  grammar.edge{from: F, to: T, label: L}.
grammarViz.unlabeledEdge{from: F, to: T, label: ""} :-
  grammar.unlabeledEdge{from: F, to: T}.
grammarViz.refEdge{from: F, to: T, label: L} :-
  grammar.refEdge{fromID: F, toID: T, ruleName: L}.
# TODO: Label = concat(FC, ":", TC)
grammarViz.charRangeEdge{from: F, to: T, label: FC} :-
  grammar.charRangeEdge{from: F, to: T, fromChar: FC, toChar: TC}.

internal.visualization{
  name: "Grammar",
  spec: graphviz{
    nodes: "grammar.node{id: ID}",
    edges: "grammarViz.edge{from: From, to: To, label: Label}"
  }
}.
