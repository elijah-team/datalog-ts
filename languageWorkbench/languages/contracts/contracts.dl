# ==== syntax highlighting ===

hl.mapping{rule: "intLit", type: "number"}.
hl.mapping{rule: "stringLit", type: "string"}.
hl.mapping{rule: "bool", type: "number"}.
hl.mapping{rule: "ident", type: "ident"}.
hl.mapping{rule: "paymentKW", type: "keyword"}.
hl.mapping{rule: "contractKW", type: "keyword"}.

# ==== mapping into DL ===

contract.Contract{id: ID, astNodeID: Stmt, contractExprID: ContractCall} :-
  ast.contractStmt{id: Stmt} &
  ast.funcArgs{id: Args, parentID: Stmt} &
  # contract call
  ast.namedFuncArg{callID: Stmt, name: "contract", exprID: ContractExpr} &
  ast.funcCall{id: ContractCall, parentID: ContractExpr} &
  # parse id
  ast.namedFuncArg{callID: Stmt, name: "id", exprID: IDExpr} &
  astInternal.node{id: IDExpr, text: IDText} &
  intToString{string: IDText, int: ID}.

# == contract nodes ==

contract.node.Payment{id: I, from: From, to: To, amount: Amt} :-
  ast.funcCall{id: I} &
  ast.varExpr{parentID: I, text: "pay"} &
  ast.namedFuncArg{callID: I, name: "from", exprID: FromExpr} &
  ast.namedFuncArg{callID: I, name: "to", exprID: ToExpr} &
  ast.namedFuncArg{callID: I, name: "amount", exprID: AmtExpr} &
  # amt
  astInternal.node{id: AmtExpr, text: AmtText} &
  intToString{string: AmtText, int: Amt} &
  # from
  ast.stringLit{parentID: FromExpr, id: FromStr} &
  ast.stringContents{parentID: FromStr, text: From} &
  # to
  ast.stringLit{parentID: ToExpr, id: ToStr} &
  ast.stringContents{parentID: ToStr, text: To}.

contract.node.And{id: I} :-
  ast.funcCall{id: I} &
  ast.varExpr{parentID: I, text: "and"}.

contract.node.Delay{id: I, duration: D} :-
  ast.funcCall{id: I} &
  ast.namedFuncArg{callID: I, name: "duration", exprID: DurationExpr} &
  # duration arg
  astInternal.node{id: DurationExpr, text: DurationText} &
  intToString{string: DurationText, int: D}.

# ==== tree structure ====

contract.tree.parent{child: C, parent: P} :-
  contract.tree.nodeParent{child: C, parent: P} |
  contract.contractRootParent{child: C, parent: P} |
  contract.Contract{id: P, contractExprID: C}.
contract.tree.nodeParent{child: ChildCall, parent: ParentCall} :-
  ast.funcCall{id: ChildCall, parentID: Expr} &
  ast.expr{id: Expr, parentID: Arg} &
  ast.funcArg{id: Arg, parentID: Args} &
  ast.funcArgs{id: Args, parentID: ParentCall} &
  ast.funcCall{id: ParentCall}.
contract.contractRootParent{child: C, parent: -1} :-
  contract.Contract{id: C}.

contract.tree.rootNode{id: -1, display: root{}}.
contract.tree.node{id: A, display: B} :-
  contract.tree.rootNode{id: A, display: B} |
  contract.tree.contractNode{id: A, display: B} |
  contract.tree.andNode{id: A, display: B} |
  contract.tree.delayNode{id: A, display: B} |
  contract.tree.paymentNode{id: A, display: B}.
contract.tree.andNode{id: I, display: and{}} :-
  contract.node.And{id: I}.
contract.tree.delayNode{id: I, display: delay{duration: D}} :-
  contract.node.Delay{id: I, duration: D}.
contract.tree.paymentNode{id: I, display: payment{from: F, to: T, amount: A}} :-
  contract.node.Payment{id: I, from: F, to: T, amount: A}.
contract.tree.contractNode{id: I, display: contract{id: I}} :-
  contract.Contract{id: I}.

contract.tree.nodeAndParent{id: A, display: B, parent: C} :-
  contract.tree.node{id: A, display: B} &
  contract.tree.parent{child: A, parent: C}.

# == payment ==

contract.PaymentRecord{id: I, contractID: CID, from: From, to: To, amount: Amt, time: T} :-
  # args from payment statement
  ast.paymentStmt{id: Payment} &
  ast.namedFuncArg{callID: Payment, name: "id", exprID: PaymentIDExpr} &
  ast.namedFuncArg{callID: Payment, name: "contractID", exprID: ContractExpr} &
  ast.namedFuncArg{callID: Payment, name: "from", exprID: FromExpr} &
  ast.namedFuncArg{callID: Payment, name: "to", exprID: ToExpr} &
  ast.namedFuncArg{callID: Payment, name: "amount", exprID: AmountExpr} &
  ast.namedFuncArg{callID: Payment, name: "time", exprID: TimeExpr} &
  # id
  astInternal.node{id: PaymentIDExpr, text: I} &
  # contract id
  astInternal.node{id: ContractExpr, text: CID} &
  # from
  ast.stringLit{id: FromStr, parentID: FromExpr} &
  ast.stringContents{parentID: FromStr, text: From} &
  # to
  ast.stringLit{id: ToStr, parentID: ToExpr} &
  ast.stringContents{parentID: ToStr, text: To} &
  # amt
  astInternal.node{id: AmountExpr, text: AmtText} &
  intToString{string: AmtText, int: Amt} &
  # time
  astInternal.node{id: TimeExpr, text: TText} &
  intToString{string: TText, int: T}.

# ==== helpers ====

ast.namedFuncArg{callID: Call, name: N, exprID: E} :-
  ast.funcArgs{id: Args, parentID: Call} &
  ast.funcArg{id: Arg, parentID: Args} &
  ast.ident{parentID: Arg, text: N} &
  ast.expr{id: E, parentID: Arg}.

# ==== viz ===

internal.visualization{
  name: "Contract Trees",
  spec: tree{
    nodes: contract.tree.nodeAndParent{id: ID, parentID: ParentID, display: Display},
    rootTerm: -1,
    sortChildren: false
  }
}.
