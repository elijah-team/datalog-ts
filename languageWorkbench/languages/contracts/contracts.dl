# ==== syntax highlighting ===

hl.mapping{rule: "intLit", type: "number"}.
hl.mapping{rule: "stringLit", type: "string"}.
hl.mapping{rule: "bool", type: "number"}.
hl.mapping{rule: "ident", type: "ident"}.
hl.mapping{rule: "paymentKW", type: "keyword"}.
hl.mapping{rule: "contractKW", type: "keyword"}.

# ==== mapping into DL ===

# == contract nodes ==

contract.node.Payment{id: I, from: From, to: To, amount: Amt} :-
  ast.funcCall{id: I} &
  ast.varExpr{parentID: I, text: "pay"} &
  ast.namedFuncArg{callID: I, name: "from", exprID: FromExpr} &
  ast.namedFuncArg{callID: I, name: "to", exprID: ToExpr} &
  ast.namedFuncArg{callID: I, name: "amount", exprID: AmtExpr} &
  # amt
  astInternal.node{id: AmtExpr, text: AmtText} &
  intToString{string: AmtText, int: Amt} &
  # from
  ast.stringLit{parentID: FromExpr, id: FromStr} &
  ast.stringContents{parentID: FromStr, text: From} &
  # to
  ast.stringLit{parentID: ToExpr, id: ToStr} &
  ast.stringContents{parentID: ToStr, text: To}.

contract.node.And{id: I} :-
  ast.funcCall{id: I} &
  ast.varExpr{parentID: I, text: "and"}.

contract.node.Delay{id: I, duration: D} :-
  ast.funcCall{id: I} &
  ast.namedFuncArg{callID: I, name: "duration", exprID: DurationExpr} &
  # duration arg
  astInternal.node{id: DurationExpr, text: DurationText} &
  intToString{string: DurationText, int: D}.

# == tree structure

contract.tree.node{id: A, display: B} :-
  contract.tree.andNode{id: A, display: B} |
  contract.tree.delayNode{id: A, display: B} |
  contract.tree.paymentNode{id: A, display: B}.
contract.tree.andNode{id: I, display: and{}} :-
  contract.node.And{id: I}.
contract.tree.delayNode{id: I, display: delay{duration: D}} :-
  contract.node.Delay{id: I, duration: D}.
contract.tree.paymentNode{id: I, display: payment{from: F, to: T, amount: A}} :-
  contract.node.Payment{id: I, from: F, to: T, amount: A}.

# == payment ==

contract.PaymentRecord{id: I, contractID: CID, from: From, to: To, amount: Amt, time: T} :-
  # args from payment statement
  ast.paymentStmt{id: Payment} &
  ast.namedFuncArg{callID: Payment, name: "id", exprID: PaymentIDExpr} &
  ast.namedFuncArg{callID: Payment, name: "contractID", exprID: ContractExpr} &
  ast.namedFuncArg{callID: Payment, name: "from", exprID: FromExpr} &
  ast.namedFuncArg{callID: Payment, name: "to", exprID: ToExpr} &
  ast.namedFuncArg{callID: Payment, name: "amount", exprID: AmountExpr} &
  ast.namedFuncArg{callID: Payment, name: "time", exprID: TimeExpr} &
  # id
  astInternal.node{id: PaymentIDExpr, text: I} &
  # contract id
  astInternal.node{id: ContractExpr, text: CID} &
  # from
  ast.stringLit{id: FromStr, parentID: FromExpr} &
  ast.stringContents{parentID: FromStr, text: From} &
  # to
  ast.stringLit{id: ToStr, parentID: ToExpr} &
  ast.stringContents{parentID: ToStr, text: To} &
  # amt
  astInternal.node{id: AmountExpr, text: AmtText} &
  intToString{string: AmtText, int: Amt} &
  # time
  astInternal.node{id: TimeExpr, text: TText} &
  intToString{string: TText, int: T}.

# ==== helpers ====

ast.namedFuncArg{callID: Call, name: N, exprID: E} :-
  ast.funcArgs{id: Args, parentID: Call} &
  ast.funcArg{id: Arg, parentID: Args} &
  ast.ident{parentID: Arg, text: N} &
  ast.expr{id: E, parentID: Arg}.
